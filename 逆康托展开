#include<bits/stdc++.h> 
using namespace std;
//对前 10 个自然数(0 ~ 9)的阶乘存入表
//以免去对其额外的计算
const int fact[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
int main()
{
	int rank=0,n;
	cin>>n>>rank;
	int a[n+1],p[n];
	memset(a,0,sizeof(a));
	rank-=1; //有rank-1个排列比目标排列小 
	int k;
	for(int i=0;i<n;i++)
	{
		k=rank/(fact[n-i-1]);
		rank=rank%(fact[n-i-1]);
		for(int j=1;j<=n;j++)
		{
			if(!a[j]&&!(k--))
			{
				a[j]=1;
				p[i]=j;
				break;
			}
		}
	}
	for(int i=0;i<n;i++)
	cout<<p[i];
	return 0;
}
/*
求字典序为n的全排列
字符数4，字典序10，-1得排在该字典序前的全排列个数
1：  9/3！，商1余3，说明首位要余出一个给 当前没用过的，最小的一个字符，因为它们占据了前 6 个排序。
	这里 “1” 没有用过，又是最小的字符，因此，我们应当使用 “2” 作为首位，并标记其已经使用。
	取余数进行下一步操作。
2:  3/2! ,商1余1，说明第二位要余出一个给 当前没用过的，最小的字符。这里 “1” 没有用过，“2” 已经用了
	因此，我们应当使用 “3” 作第二位。
3： 1/1！，商1余0，说明第三位要余出一个给 当前没用过的，最小的字符。这里 “1” 没有用过，“2” 已经用了，
	“3”也用了。因此，我们应当使用 “4” 作第三位。
4： 同康托展开，最后一位无需判断，所有字符中至今未使用的填入即可。
*/
